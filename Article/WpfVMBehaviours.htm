
<head>
</head>

<h1>Introduction</h1>
<p>It has been a while since I have written an article, I have had this one on 
my back burner list for a while, so I thought it high time that I get it out 
there. In some ways this article is a strange one, as 1/2 of it is kind of throw 
away, and merely serves as a vehicle to demonstrate the parts that I actually do 
think are very useful and can be applied to a whole range of different 
application styles/platforms.</p>
<p>&nbsp;</p>
<p><strong>So what is this article about exactly?</strong></p>
<p>Quite simply it is about how to structure large codebases. I am not claiming 
that there are not other ways, rather I am claiming this is certainly one way 
that I personally have found to be incredibly useful. To give you an idea of my 
current code base I am using MVVM/WPF and have around 1500 ViewModels, my UI 
codebase alone is around 150,000 lines of code.</p>
<p>This is not the 1st WPF/MVVM application I have written, but when I look at 
my current code base compared to older codebases that I worked on, I do get a 
warm feeling in the knowledge that my new codebase is way more maintainable and 
testable.</p>
<p>&nbsp;</p>
<p><strong>How has this come about</strong></p>
<p>Well as I say in my (and others) older code bases people were still finding 
their way with MVVM (which was a new pattern at the time, or at the very least a 
rebranded one), and composition of ViewModels etc etc Essentially it was 
unfamiliar ground. Ok there were certain tools that 
helped with this, one such tool was the now famous <code>DelegateCommand </code>
(or Josh Smiths <code>RelayCommand</code>) which allowed you to run <code>
ICommand </code>implementation code directly in your ViewModel. So that helped, 
and soon everyone was happily creating loads of <code>DelegateCommand</code>(s) 
in their ViewModels. Some clever folk actually went the extra mile and 
implemented the Command Pattern properly, but most didn't, and just had loads of
<code>DelegateCommand</code>(s) in their ViewModel(s). Nothing wrong with that, 
until.....</p>
<p>&nbsp;</p>
<p>You realise you ViewModel is now getting very large due to the sheer number 
of properties it has to expose, and also the number of <code>DelegateCommand</code>(s) 
it must accomodate. Each of these <code>DelegateCommand</code>(s) may call out 
to additional services such as WCF Proxies, Http services etc etc, and the <code>
DelegateCommand </code>logic may also deal with retries and showing errors to 
the user, so its not difficult to imagine that one <code>
DelegateCommand.Execute() </code>method could end up with between 30-100 lines, 
multiply that by the number of <code>DelegateCommand</code>(s) in your ViewModel 
and you can quite easily see how out of hand this can get.</p>
<p>Before long I realised this was not a good idea, and I started create more 
modular ViewModels. That helped for a while., but then that started to fall 
apart on occasion, where I realised there were scenarios where the logical split between 
ViewModels still ended up in situations where that there was still a big 
ViewModel, and I could not see a way out of that. I caved in, the occassion big 
ViewModel sigh, ok.</p>
<p>&nbsp;</p>
<p>Around the same time I took a new job working at a tier 1 bank and met some 
very smart developers called</p>
<ul>
	<li><strong>Ray Booysen</strong></li>
	<li><strong>Keith Woods</strong></li>
</ul>
<p>&nbsp;</p>
<p>These guys were making heavy use of the Reactive Extensions (RX), which was 
fairly new to me at the time, and also talked quite often about VM Behaviours. 
At the time I did not fully understand what Ray/Keith were talking about, but 
after I left that job, I had a good old think about the problem, and was like 
aha I get it now.</p>
<p>&nbsp;</p>
<p>What Ray/Keith were talking about was creating small bits of 
isolated functionality that did one thing and one thing only (Yes our old friend 
Seperation Of Concern <strong>SOC</strong>), and kind of associating 
that bit of functionality with a ViewModel instance. The way I like to think of 
this is &quot;<strong>Attached Behaviours For ViewModels</strong>&quot;. This was achieved using a number 
of techniques such as </p>
<ul>
	<li>Child IOC containers</li>
	<li>RX</li>
	<li>Specific IOC services to manage the ViewModel</li>
</ul>
<p>&nbsp;</p>
<p>The rest of this article will talk about my journey into this brighter world 
(that's a tongue in cheek joke by the way). This technique may not be for 
everyone, some may even suggest that it breaks the &quot;Law Of Demeter&quot; which I 
personally think should be renamed &quot;The Occassionally Useful Law Of Demeter&quot;.</p>
<p>&nbsp;</p>
<p>Anyway lets get on with the article shall we.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>

<h1>Demo Video</h1>
<p>I have posted a small YouTube video of the demo app in action. You can see 
that video by clicking on the link below:</p>
<p><a href="https://www.youtube.com/watch?v=d6rOiiXRZyY" target="_blank">
https://www.youtube.com/watch?v=d6rOiiXRZyY</a></p>
<p>&nbsp;</p>
<h1>ScreenShot </h1>
<p>Here is a screen shot as well</p>
<p><a href="DemoBig.png" target="_blank"><img alt="" height="354" src="DemoSmall.png" width="630"></a></p>
<p>&nbsp;</p>
<p><em>CLICK THE IMAGE TO SEE A BIGGER VERSION</em></p>
<p>&nbsp;</p>
<h1>Prerequisites</h1>
<p>The demo code is made using VS2013, and .NET 4.5, as such you will need 
both of those to run the demo app correctly.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>


<h1>Where Is The Code?</h1>
<p>The code for this article is available on my GitHub account :</p>
<p>
<a href="https://github.com/sachabarber/WpfVMBehaviourshttps://github.com/sachabarber/WpfVMBehaviours">
https://github.com/sachabarber/WpfVMBehaviours</a></p>
<p>&nbsp;</p>
<p>Don't forget if you like the rest of this article, and the ideas herein you 
can always Star the GitHub repository ;-)</p>
<p>&nbsp;</p>
<h3>How To Run The Code</h3>
<p>Once/if you download the code, you will need to run it. This is pretty reasy 
just ensure that the following project is set to be the startup project in the 
Visual Studio IDE&nbsp;</p>
<ul>
	<li><code>WpfBehaviours.Shell</code></li>
</ul>
<p>&nbsp;</p>
<p>&nbsp;</p>


<h1>A Note About Navigation (The Mule)</h1>
<p>&nbsp;</p>
<p>I am entitled this section &quot;The Mule&quot; as it is really not that important, it 
is a vehicle to allow the demonstration of the rest of the article. That is not 
to say Mules are useless, they are infact very useful and there may be some&nbsp; 
amongst you who after reading this, may actually like how I packed &quot;The Mules 
(AKA
<a href="http://compositewpf.codeplex.com/" target="_blank">PRISM 4.1</a>)&quot; 
saddle bags, and want to take him for your own ride.</p>
<p>&nbsp;</p>
<p>For this demo app I am using
<a href="http://compositewpf.codeplex.com/" target="_blank">PRISM 4.1</a> for 
the navigation functionality ONLY, as I think&nbsp;
<a href="http://compositewpf.codeplex.com/" target="_blank">PRISM 4.1</a> does 
offer an excellent navigation framework for WPF/Silverlight/Windows Phones apps. 
I am of course aware there is a newer version available, but I had some code 
lying about that I could make use of that targeted
<a href="http://compositewpf.codeplex.com/" target="_blank">PRISM 4.1</a> and 
the newer version of PRISM is different enough that I would have to redo this 
work. As I say in this article its all about other stuff the Navigation is a 
nice to have, that I just happened to be able to provide easily by using
<a href="http://compositewpf.codeplex.com/" target="_blank">PRISM 4.1</a>.</p>
<p>&nbsp;</p>
<p>The truth is you could apply the techniques I am talking about in this to any 
Windows platform that you can work with that supports IOC containers and RX. You 
could even apply this to a Windows Forms application where you might use the 
Model-View-Presenter pattern.</p>
<p>I guess what I am really saying is that there is quite a bit of custom
<a href="http://compositewpf.codeplex.com/" target="_blank">PRISM 4.1</a> region stuff 
that has been written to make
<a href="http://compositewpf.codeplex.com/" target="_blank">PRISM 4.1</a> be 
able to navigate using a child IOC container in the attached demo article, but you should <span style="background:yellow; border:1px black solid">NOT pay too much 
attention to that, as that is NOT really what the article is about</span></p>
<p>&nbsp;</p>


<p>If you are interested in how I achieved that you can read a completely 
separate article I wrote about this some time ago:</p>
<p>
<a href="http://www.codeproject.com/Articles/640573/ViewModel-st-Child-Container-PRISM-Navigation" target="_blank">
http://www.codeproject.com/Articles/640573/ViewModel-st-Child-Container-PRISM-Navigation</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>


<h1>The Good Stuff</h1>
<p>From here on in is what I consider to be the good/useful stuff in this 
article that could be applied to other project types, such as :</p>
<ul>
	<li>WPF Applications</li>
	<li>Windows Store Applications</li>
	<li>Silverlight Applications</li>
	<li>Windows Phone Applications</li>
	<li>Universal Applications</li>
</ul>
<p>&nbsp;</p>
<h2>The General Idea</h2>
<p>The general idea behind this architecture is that you may know in advance 
that you are going to have some pretty knarly UI requirements. I for example 
work creating trading apps, and regularly have requirements that involve UIs 
that have cross dependencies between many interconnected ViewModels. Where there 
may be relationships to parent ViewModels, or possibly even grand parent 
ViewModels, or between siblings. It can be be a nightmare, imagine all those
<code>INotifyPropertyChanged </code>event(s) that you will need to not only 
monitor, but also unhook at the correct time. Argghhh</p>
<p>Now trying to shoe horn this into a single ViewModel is just not going to 
work. Thing is we live in modern times, and can make use of modern tooling, 
which for me includes things like RX/IOC Containers. These are certainly 2 heavy 
hitters in the implemention of the demo app/framework I am presenting here.</p>
<p>If this all sounds quite vague don't worry you will see lots of code, we are 
just setting the scene for it.</p>
<p>&nbsp;</p>
<p>So what is the basic idea, well before we get to that, it helps to kind of 
think about our UI a bit more. Like I say I work creating trading apps, where I 
have typically have <strong>closeable</strong> Tabs/Tiles of the same type of 
ViewModel I must show over and over again (different instances of course). So it 
kind of makes sense for the creation of that ViewModel and its dependencies to 
be isolated from the creation of another instance of the same type of ViewModel.</p>
<p>Now, you may have come across lots of Inversion Of Control (IOC) examples 
about how to inject services into ViewModel instances. Thing is you never really 
see that many that deal with actual IOC component lifecyles and how that works 
within your app.</p>
<p>&nbsp;</p>
<ul>
	<li>Imagine you has a shared service, but you wanted it to only be a 
	singleton to a certain type of ViewModel. Mmmm.&nbsp;</li>
	<li>And also how would the IOC container know when to release things? Mmmm</li>
	<li>Or you want each tile to get a singleton instance scoped to it alone. 
	Mmmm</li>
</ul>
<p>&nbsp;</p>
<p>I have pondered this a lot, and IOC resolved dependencies and having a highly 
composable UI are things that interest/concern me. And that is what this article 
is really about.</p>
<p>So some bullet points</p>
<p>&nbsp;</p>
<ul>
	<li>We will assume that for each new part (view) that is being navigated to, 
	that we will use a Child IOC Container</li>
	<li>We will couple (Strongly) the newly created IOC container the the 
	lifecycle of the ViewModel such that when the ViewModel is closed (no longer 
	needed) the child container and all the held dependencies it created for the 
	current ViewModel will be Disposed</li>
	<li>We will create a set of ViewModel behaviours (some of you may have seen 
	MVVM + Controller, so you can think of ViewModel Behaviours as Micro 
	Controllers for the ViewModel instance). The beauty of these &quot;Micro 
	controllers&quot; is that you can VERY easily find where some code is that does a 
	certain action, and you will know it will not impact anything else as is is 
	also following the <strong>Separation Of Concerns</strong> ideals.</li>
	<li>The ViewModel behaviours will be applied with nothing more than a single 
	IOC registration</li>
	<li>The ViewModel behaviours will be able to monitor the ViewModel using RX 
	(this is awesome the more I use it the more I love it)</li>
</ul>
<p>&nbsp;</p>
<p>Some of you may baulk at the &quot;Airy Fairyness&quot; of this, and yeah fair enough, 
but I honestly am telling you by following this pattern I feel I have finally 
found my XAML nirvana/sweet spot.</p>
<p>&nbsp;</p>
<p>Anyway here is a diagram which I hope illustrates what I am talking about 
here:</p>
<p>&nbsp;</p>
<p>Here is a screen shot as well</p>
<p><a href="WiringBig.png" target="_blank"><img alt="" height="428" src="WiringSmall.png" width="630"></a></p>
<p>&nbsp;</p>
<p><em>CLICK THE IMAGE TO SEE A BIGGER VERSION</em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>A Deeper Dive Into The Guts Of It</h2>
<p>This section will dig a lot deeper into the specifics of how to achieve all 
the good stuff mentioned above. As I have stated already I am using
<a href="http://compositewpf.codeplex.com/" target="_blank">PRISM 4.1</a>, but 
as I have also stated, the techniques that have been/will be demonstrated in this 
article would work equally well anywhere where you have a stateful UI, and you 
use navigation, so things like Windows Phone apps, Silverlight, even Windows 
forms could be a good candidate for this (where you might use the 
Model-View-Presenter pattern instead of MVVM).</p>
<p>&nbsp;</p>
<h3>Thinking In Composable Views</h3>
<h3>Child Containers</h3>
<h3>Disposable ViewModels / Child Container Lifecycle Management</h3>
<h3>ViewModel Behaviours</h3>
<h3>Reactive Commands</h3>
<h3>Further Case For RX</h3>
<h3>Typical RX Usage&nbsp;</h3>
<p>&nbsp;</p>
<h1>That's It</h1>
<p>Anyway that is all I wanted to say this time. I do have another VERY LARGE 
article I am working on right now on CQRS, that I hope to have out soon. That 
will take a me a while to finish so until then, could I just ask if you liked 
this article could you spare 2 minutes to leave a comment/question, or a vote, 
they are always welcome.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
